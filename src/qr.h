#ifndef __QR_H
#define __QR_H

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include "qr_types.h"
#include "qr_data.h"
#include "qr_gf256.h"
#include "qr_render.h"
#include "qr_rank.h"
#include "qr_debug.h"




class CQrGen {
    public:
        /**
         * Creates a QR code from raw data, renders the bitmap, adds format information and applies a mask
         * @param data raw data to encode
         * @param length length of the data
         * @param mode QR mode to use (default: QrMode::Unspecified, which means auto-detect)
         * @param ecLevel QR error correction level to use (default: QrEcc::L)
         * @return a QrCode object containing the encoded data and the rendered bitmap
         */
        QrCode* create(const char* data, uint16_t length, QrMode mode = QrMode::Unspecified, QrEcc ecLevel = QrEcc::L){
            QrCode *result = createRaw(data, length, mode, ecLevel);
            setFormat(result);
            QrRenderer.render(result);
            QrRenderer.renderFormat(result);
            applyBestMask(result);

            return result;
        }

        /**
         * Creates a QR code from raw data without rendering the bitmap (allocates space though)
         * @param data raw data to encode
         * @param length length of the data
         * @param mode QR mode to use (default: QrMode::Unspecified, which means auto-detect)
         * @param ecLevel QR error correction level to use (default: QrEcc::L)
         * @return QrCode object
         */
        QrCode* createRaw(const char* data, uint16_t length, QrMode mode = QrMode::Unspecified, QrEcc ecLevel = QrEcc::L) {
            if (mode == QrMode::Unspecified)
                mode = this->getMode(data, length);
            uint8_t version = this->getVersion(length, mode, ecLevel);
            QrCode *result = new QrCode(version, ecLevel);

            QrBlockStruct s = qr_blocks[version][ecLevel];
            uint8_t *buff = new uint8_t[s.totalWords()];
            memset(buff, 0, s.totalWords());
            QrBufferCursor buffCur;
            
            addValue(buff, &buffCur, qr_mode_indicator[mode], 4);
            addValue(buff, &buffCur, length, qr_lengthBits(version, mode));
            addData(buff, &buffCur, data, length, mode);

            addPadding(buff, &buffCur, s.dataWords());

            uint16_t edcLen = 0;
            uint8_t *edc = Gf256.getEdc(buff, buffCur.byte, s.totalWords(), edcLen);
            memcpy(buff+buffCur.byte, edc, edcLen);
            delete[] edc;

            result->raw = buff;
            result->rawSize = buffCur.byte + edcLen;

            return result;
        }

       
        /**
         * Sets the format information for a given QR code by mapping the error correction level 
         * and mask pattern to a 15-bit format string. The mapping involves a bitwise operation 
         * with a predefined mask, and the result is stored in the formatPoly field of the QR code. 
         * This function ensures that the error correction level (ecLevel) is mapped using a specific 
         * conversion table and the final format string is generated by performing a long division 
         * using a generator polynomial.
         *
         * @param code Pointer to the QrCode object whose format information is to be set.
         */
        void setFormat(QrCode *code){
            // Need to map ecLevel according to the table below
            // Note that only the last bit is flipped
            //                L  M  Q  H
            // Logical value  00 01 10 11
            // Mapped value   01 00 11 10
            int8_t 
                ec = code->ecLevel ^ 0x01,
                m = code->mask,
                i;
            uint16_t 
                f = ((ec << 3) | m) << 10,
                t = f,
                d = qr_format_divisor;

            for(i = 4; i >= 0; i--){
                // 0000 0100 0000 0000
                if (t & (0x400 << i)){
                    t ^= d << i;
                }
            }

            f |= t;
            f ^= qr_format_mask;
            code->formatPoly = f;
        }
        
        /**
         * Applies the best mask to the QR code. It does this by computing the rank of the QR code with each mask and then
         * selecting the mask with the lowest rank.
         * @param code The QR code to apply the best mask to
         */
        void applyBestMask(QrCode *code){
            uint16_t scores[8] = {QrRanker.rank(code)};
            for(uint8_t i = 1; i < 8; i++){
                changeMask(code, i);
                scores[i] = QrRanker.rank(code);
            }

            uint8_t mi = 0;
            for (uint8_t i = 0; i < 8; i++){
                if (scores[i] < scores[mi]) mi = i;
            }
            changeMask(code, mi);
        }

        /**
         * Changes the mask applied to the given QR code by first removing the existing mask and then
         * applying the new specified mask. Updates the QR code's mask property and format information,
         * and re-renders the format to reflect the changes.
         *
         * @param code Pointer to the QrCode object to which the mask change should be applied.
         * @param mask The new mask pattern to apply to the QR code.
         */
        void changeMask(QrCode *code, uint8_t mask){
            QrRenderer.applyMask(code, code->mask);
            QrRenderer.applyMask(code, mask);
            code->mask = mask;
            setFormat(code);
            QrRenderer.renderFormat(code);
        }


        /**
         * Determines the most suitable QR mode for the given data based on its content.
         * 
         * This function analyzes the input data to identify the QR mode that can efficiently 
         * encode it. It prioritizes the most restrictive mode that can represent the data 
         * to ensure compactness. The function considers the following modes:
         * - Numeric: If the data contains only digits (0-9).
         * - Alphanumeric: If the data contains uppercase letters (A-Z), digits (0-9), and 
         *   certain special characters (' ', '$', '%', '*', '+', '-', '.', '/', ':').
         * - Byte: If the data contains characters that do not fit in the Numeric or 
         *   Alphanumeric modes.
         * 
         * @param data A pointer to the raw data to analyze.
         * @param length The length of the data.
         * @return The most suitable QrMode (Numeric, AlphaNumeric, or Byte) for the data.
         */

        QrMode getMode(const char* data, uint16_t length) {
            uint8_t modes = 0b111,
                isAplha = 0;
            for(uint16_t i = 0; i < length; i++){
                uint8_t r = 0b100;
                if (data[i] >= '0' && data[i] <= '9') r |= 0b011;
                if (data[i] >= 'A' && data[i] <= 'Z') r |= 0b010;

                isAplha = false;
                for(uint8_t j = 0; j < 9; j++){
                    if (qr_alphanum_chars[j] == data[i]) isAplha = true;
                }
                if (isAplha) r |= 0b010;

                modes &= r;

                if(modes == 4)
                return QrMode::Byte;
            }
            if (modes & 1) return QrMode::Numeric;
            if (modes & 2) return QrMode::AlphaNumeric;
            return QrMode::Byte;
        };
        /**
         * Gets the smallest suitable version for a given mode and length
         * @returns 0-based version number (0-39)
         */
        uint8_t getVersion(uint16_t length, QrMode mode, QrEcc ecLevel){
            for(uint8_t i = 0; i < 40; i++) {
                if(qr_capacities[mode][i][ecLevel] > length) return i;
            }
            return 0xFF;
        }

        void addData(uint8_t *buff, QrBufferCursor *cursor, const char* data, uint16_t length, QrMode mode){
            switch(mode) {
                case QrMode::Numeric:
                    return this->addDataNum(data, length, buff, cursor);
                case QrMode::AlphaNumeric:
                    return this->addDataAlpha(data, length, buff, cursor);
                case QrMode::Byte:
                    return this->addDataByte(data, length, buff, cursor);
            }
        }
        void addDataNum(const char *data, uint16_t length, uint8_t *buff, QrBufferCursor *cursor){
            uint16_t i = 0;
            uint16_t acc = 0;
            while (i < length) {
                acc = (acc*10)+(data[i] - '0');
                i++;
                if (i % 3 > 0) continue;

                addValue(buff, cursor, acc, 10);
                acc = 0;
            } 
            if (i%3 >0) {
                uint8_t rem  = 3 - (i % 3);
                for (uint8_t j = 0; j <rem; j++){
                    acc = acc*10;
                }
                addValue(buff, cursor, acc, 10);
            }
        }
        void addDataAlpha(const char *data, uint16_t length, uint8_t *buff, QrBufferCursor *cursor){
            uint16_t i = 0;
            uint16_t acc = 0;
            while (i < length) {
                uint8_t d = 0;
                if (data[i] >= '0' && data[i] <= '9')
                    d = data[i] - '0';
                else if (data[i] >= 'A' && data[i] <= 'Z')
                    d = 10 + data[i] - 'A';
                else {
                    for(uint8_t j = 0;j < 9;j++) {
                        if (qr_alphanum_chars[j] != data[i]) continue;
                        d = 36 + j;
                        j = 9;
                    }
                }
                if (i & 1) 
                    acc *= 45; 
                acc += d;
                i++;  
                
                if (i & 1) continue;
                addValue(buff, cursor, acc, 11);

                acc = 0;
            } 
            
            if (i & 1) {
                acc *= 45;
                addValue(buff, cursor, acc, 11);
            }

        }
        void addDataByte(const char *data, uint16_t length, uint8_t *buff, QrBufferCursor *cursor){
            uint16_t i = 0;
            while (i < length) {
                addValue(buff, cursor, data[i], 8);
                i++;
            } 
        }
        void addValue(uint8_t *buff, QrBufferCursor *cursor, uint16_t value, uint8_t bitLength) {
            if (bitLength > 8){
                addValue(buff, cursor, value >> 8, bitLength - 8);
                addValue(buff, cursor, value & 0xFF, 8);
                return;
            }

            int8_t sh = 8 - cursor->bit - bitLength;
            if (sh >= 0){
                buff[cursor->byte] |= value << sh;
                cursor->bit += bitLength;
            } else {
                buff[cursor->byte] |= value >> (-sh);
                cursor->bit = 0;
                cursor->byte++;
                
                
                buff[cursor->byte] |= value << (8+sh);
                cursor->bit += -sh;
            }

            if (cursor->bit == 8) {
                cursor->bit = 0;
                cursor->byte++;
            }
        }
    
        /**
         * Adds padding to the QR code data buffer to ensure it reaches the required length.
         * 
         * This function first adds a 4-bit terminator to the data buffer. If the current bit position
         * within the current byte is not aligned (i.e., not zero), it pads the remaining bits of 
         * the current byte with zeros to align to the next byte boundary. After that, it alternates 
         * between adding the bytes 236 and 17 to the buffer until the buffer length reaches the specified 
         * length 'len'. The padding helps ensure the QR code has a fixed size and is compliant with 
         * specifications.
         *
         * @param buff Pointer to the buffer where the data is stored.
         * @param cursor Pointer to the QrBufferCursor struct that tracks the current byte and bit position 
         * in the buffer.
         * @param len The length in bytes that the buffer should reach after padding.
         */
        void addPadding(uint8_t *buff, QrBufferCursor *cursor, uint16_t len){
            addValue(buff,cursor,0,4);
            if(cursor->bit != 0){
                addValue(buff, cursor, 0, 8-cursor->bit);
            }

            uint8_t f = 0;
            while(cursor->byte < len){
                addValue(buff,cursor, f ? 17 : 236, 8);
                f = !f;
            }
        }
};

CQrGen QrGenerator;

#endif //__QR_H